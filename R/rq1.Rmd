---
title: "RQ1"
author: CÃ©sar Soto Valero
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    df_print: paged
    css: main.css
    number_sections: true
    toc: false
    toc_depth: 3
    toc_float: 
      collapsed: false
---

# Header

```{r echo=FALSE, message=FALSE, warning=FALSE}
# Import the header 
source("header.R")
# Clear the R environment
rm(list=ls())
```

# Read the data

```{r echo=FALSE}
raw_results <- read.delim("Data/results_dependabot_with_commit_dates.csv", sep = ",", header = T, stringsAsFactors = TRUE)
```

# Preprocess the data

```{r echo=FALSE}
# Cast date variable from factor to Date
raw_results$Date <- as.Date(raw_results$Date)

# Arrange by version
results <- raw_results %>% 
  mutate(VersionTMP = Version) %>%
  separate(VersionTMP, c("V1", "V2", "V3"), "\\.") %>% 
  mutate(V1 = as.numeric(V1), V2 = as.numeric(V2), V3 = as.numeric(V3)) %>% 
  arrange(Project, Date)

# Numbering rows withing groups
results <- results %>% 
  group_by(Project) %>% 
  mutate(CommitOrder = row_number())

results <- results %>% 
  mutate(TotalUsed = UsedDirect + UsedTransitive, TotalBloated = BloatedDirect + BloatedTransitive)

# Remove projects with only one commit (not possible to find the trend for them)
projects_single_commit <- results %>% 
  count(Project) %>% 
  filter(n == 1)

results <- results[!(results$Project %in% projects_single_commit$Project),]
  
View(results)
```

# Descriptive

```{r echo=FALSE}
df <- results %>% count(Project) %>% arrange(desc(n))

print(paste("Total projects:", nrow(df)))
print(paste("Average size of the time series:", mean(df$n)))
print(paste("Median size of the time series:", median(df$n)))
print(paste("Max size of the time series:", max(df$n)))
print(paste("Min size of the time series:", min(df$n)))

# Summary of the number of commits
summary(df$n)

# The last commit
df_last_commit <- results %>% 
  group_by(Project) %>% 
  filter(CommitOrder == max(CommitOrder))

summary(df_last_commit$UsedDirect)
summary(df_last_commit$UsedTransitive)
summary(df_last_commit$BloatedTransitive)
summary(df_last_commit$BloatedDirect)
```

# Determine the time series for which the bloated deps are: increasing, decreasing, variable

## Bloated direct

```{r}
df <- results %>% 
  select(Project, CommitOrder, BloatedDirect, TotalUsed) %>% 
  group_by(Project) %>% 
  mutate(BloatIncreaseOnly = !is.unsorted(BloatedDirect) & var(BloatedDirect) != 0,
         BloatDecreaseOnly = !is.unsorted(rev(BloatedDirect)) & var(BloatedDirect) != 0,
         BloatIsStable = ifelse(var(BloatedDirect) == 0, TRUE, FALSE),
         BloatIsVariable = ifelse(BloatIncreaseOnly == FALSE & BloatDecreaseOnly == FALSE && BloatIsStable == FALSE, TRUE, FALSE)) %>% 
  select(Project, BloatIncreaseOnly, BloatDecreaseOnly, BloatIsStable, BloatIsVariable) %>% 
  distinct()

summary(df)
inc_only_bd <- table(df$BloatIncreaseOnly)[2]
dec_only_bd <- table(df$BloatDecreaseOnly)[2]
sta_bd <- table(df$BloatIsStable)[2]
var_bd <- table(df$BloatIsVariable)[2]

# Create plot
tmp <- data.frame(Bloat = c("Increase", "Decrease", "Stable", "Variable"), Projects = c(inc_only_bd, dec_only_bd, sta_bd, var_bd))
result_plot <- tmp %>%  ggplot(aes(Bloat, Projects, fill = Bloat)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label=Projects), vjust=-0.5) + 
  ylim(0, 800) +
  xlab("Bloat trend") +
  ylab("Projects") +
  ggtitle("bloated-direct") +
  theme(legend.position="none")

# Save the plot
ggsave(filename = "Figures/barplot_trend_bd.pdf", plot = result_plot,
       height = 2, width = 4,  units = c("in"), device = "pdf")
save_figure(result_plot, "Figures/barplot_trend_bd", 4, 2)

```

## Bloated transitive

```{r}
df <- results %>% 
  select(Project, CommitOrder, BloatedTransitive, TotalUsed) %>% 
  group_by(Project) %>% 
  mutate(BloatIncreaseOnly = !is.unsorted(BloatedTransitive) & var(BloatedTransitive) != 0,
         BloatDecreaseOnly = !is.unsorted(rev(BloatedTransitive)) & var(BloatedTransitive) != 0,
         BloatIsStable = ifelse(var(BloatedTransitive) == 0, TRUE, FALSE),
         BloatIsVariable = ifelse(BloatIncreaseOnly == FALSE & BloatDecreaseOnly == FALSE && BloatIsStable == FALSE, TRUE, FALSE)) %>% 
  select(Project, BloatIncreaseOnly, BloatDecreaseOnly, BloatIsStable, BloatIsVariable) %>% 
  distinct()

summary(df)

inc_only_bt <- table(df$BloatIncreaseOnly)[2]
dec_only_bt <- table(df$BloatDecreaseOnly)[2]
sta_bt <- table(df$BloatIsStable)[2]
var_bt <- table(df$BloatIsVariable)[2]

# Create plot
tmp <- data.frame(Bloat = c("Increase", "Decrease", "Stable", "Variable"), Projects = c(inc_only_bt, dec_only_bt, sta_bt, var_bt))
result_plot <- tmp %>%  ggplot(aes(Bloat, Projects, fill = Bloat)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label=Projects), vjust=-0.5) + 
  ylim(0, 800) +
  xlab("Bloat trend") +
  ylab("Projects") +
  ggtitle("bloated-transitive") +
  theme(legend.position="none")

# Save the plot
ggsave(filename = "Figures/barplot_trend_bt.pdf", plot = result_plot,
       height = 2, width = 4,  units = c("in"), device = "pdf")
save_figure(result_plot, "Figures/barplot_trend_bt", 4, 2)

```

# Analyze the slope of the variable ts

## Bloated direct

```{r}
df <- results %>% 
  select(Project, CommitOrder, BloatedDirect, TotalUsed) %>% 
  group_by(Project) %>% 
  mutate(BloatIncreaseOnly = !is.unsorted(BloatedDirect) & var(BloatedDirect) != 0,
         BloatDecreaseOnly = !is.unsorted(rev(BloatedDirect)) & var(BloatedDirect) != 0,
         BloatIsStable = ifelse(var(BloatedDirect) == 0, TRUE, FALSE),
         BloatIsVariable = ifelse(BloatIncreaseOnly == FALSE & BloatDecreaseOnly == FALSE && BloatIsStable == FALSE, TRUE, FALSE)) %>% 
  filter(BloatIsVariable == TRUE) # %>% 
  # filter(Project == "7le/shine-mq" | Project == "adyliu/jafka")

# Functions
doModel <- function(dat) lm(CommitOrder ~ BloatedDirect, dat)
getSlope <- function(mod) coef(mod)[[2]]

models <- df %>% 
  group_by(Project) %>%
  nest %>%
  mutate(model = map(data, doModel)) %>% 
  mutate(slope = map(model, getSlope))

models

# Make a plot for validation purposes
# df %>% 
#   ggplot(aes(CommitOrder, BloatedDirect)) +
#   geom_point() +
#   geom_smooth(method='lm') +
#   facet_grid(.~ Project)

# Get all the slopes in a data frame
slopes <- models$slope
array_slopes <- c()
for (i in 1:length(slopes)) {
  array_slopes <- c(array_slopes, slopes[[i]])
  print(slopes[[i]])
}

df_slopes <- data.frame(Slopes = array_slopes, Projects = models$Project)

df_slopes <- df_slopes %>% 
  mutate(Sign = ifelse(Slopes > 0, "inc", "dec"))

tmp <- df_slopes %>% count(Sign)

inc_bd <- tmp$n[2]
dec_bd <- tmp$n[1]

# Create plot
result_plot <- tmp %>%  
  ggplot(aes(Sign, n, fill = Sign)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label=n), vjust=-0.5) + 
  ylim(0, 600) +
  xlab("Bloat trend") +
  ylab("Projects") +
  ggtitle("bloated-direct")
  theme(legend.position="none")

# Save the plot
ggsave(filename = "Figures/barplot_slope_bd.pdf", plot = result_plot,
       height = 2, width = 4,  units = c("in"), device = "pdf")
save_figure(result_plot, "Figures/barplot_slope_bd", 4, 2)
```

## Bloated transitive

```{r}
df <- results %>% 
  select(Project, CommitOrder, BloatedTransitive, TotalUsed) %>% 
  group_by(Project) %>% 
  mutate(BloatIncreaseOnly = !is.unsorted(BloatedTransitive) & var(BloatedTransitive) != 0,
         BloatDecreaseOnly = !is.unsorted(rev(BloatedTransitive)) & var(BloatedTransitive) != 0,
         BloatIsStable = ifelse(var(BloatedTransitive) == 0, TRUE, FALSE),
         BloatIsVariable = ifelse(BloatIncreaseOnly == FALSE & BloatDecreaseOnly == FALSE && BloatIsStable == FALSE, TRUE, FALSE)) %>% 
  filter(BloatIsVariable == TRUE) # %>% 
  # filter(Project == "7le/shine-mq" | Project == "adyliu/jafka")

# Functions
doModel <- function(dat) lm(CommitOrder ~ BloatedTransitive, dat)
getSlope <- function(mod) coef(mod)[[2]]

models <- df %>% 
  group_by(Project) %>%
  nest %>%
  mutate(model = map(data, doModel)) %>% 
  mutate(slope = map(model, getSlope))

models

# Make a plot for validation purposes
# df %>% 
#   ggplot(aes(CommitOrder, BloatedTransitive)) +
#   geom_point() +
#   geom_smooth(method='lm') +
#   facet_grid(.~ Project)

# Get all the slopes in a data frame
slopes <- models$slope
array_slopes <- c()
for (i in 1:length(slopes)) {
  array_slopes <- c(array_slopes, slopes[[i]])
  print(slopes[[i]])
}

df_slopes <- data.frame(Slopes = array_slopes, Projects = models$Project)

df_slopes <- df_slopes %>% 
  mutate(Sign = ifelse(Slopes > 0, "inc", "dec"))

tmp <- df_slopes %>% count(Sign)

inc_bt <- tmp$n[2]
dec_bt <- tmp$n[1]

# Create plot
result_plot <- tmp %>%  
  ggplot(aes(Sign, n, fill = Sign)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label=n), vjust=-0.5) + 
  ylim(0, 600) +
  xlab("Bloat trend") +
  ylab("Projects") +
  ggtitle("bloated-transitive")
  theme(legend.position="none")

# Save the plot
ggsave(filename = "Figures/barplot_slope_bt.pdf", plot = result_plot,
       height = 2, width = 4,  units = c("in"), device = "pdf")
save_figure(result_plot, "Figures/barplot_slope_bt", 4, 2)
```



# Plot a custom bar plot

```{r}
# Create plot
tmp <- data.frame(Bloat = c("inc_only", "dec_only", "inc", "dec", "stable", "inc_only", "dec_only", "inc", "dec", "stable"), 
                  Projects = c(inc_only_bd, dec_only_bd, inc_bd, dec_bd, sta_bd, inc_only_bt, dec_only_bt, inc_bt, dec_bt, sta_bt),
                  Type = c("bloated-direct", "bloated-direct", "bloated-direct", "bloated-direct", "bloated-direct", "bloated-transitive", "bloated-transitive", "bloated-transitive", "bloated-transitive", "bloated-transitive"))
tmp$Bloat <- factor(tmp$Bloat,levels = c("inc_only", "dec_only", "inc", "dec", "stable"))

result_plot <- tmp %>%  ggplot(aes(Bloat, Projects, fill = Bloat)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label=Projects), vjust=-0.5) + 
  ylim(0, 600) +
  xlab("Bloat trend") +
  ylab("#Projects") +
  facet_grid(Type ~ .) +
  theme(legend.position="none")

# Save the plot
ggsave(filename = "Figures/barplot_trend.pdf", plot = result_plot,
       height = 3, width = 4,  units = c("in"), device = "pdf")
save_figure(result_plot, "Figures/barplot_trend", 4, 3)
```


# Box plot of the length of time series for each class

```{r}
df <- results %>% 
  select(Project, CommitOrder, TotalBloated, TotalUsed) %>% 
  group_by(Project) %>% 
  mutate(BloatIncreaseOnly = !is.unsorted(TotalBloated) & var(TotalBloated) != 0,
         BloatDecreaseOnly = !is.unsorted(rev(TotalBloated)) & var(TotalBloated) != 0,
         BloatIsStable = ifelse(var(TotalBloated) == 0, TRUE, FALSE),
         BloatIsVariable = ifelse(BloatIncreaseOnly == FALSE & BloatDecreaseOnly == FALSE && BloatIsStable == FALSE, TRUE, FALSE)) %>% 
  mutate(Class = ifelse(BloatIncreaseOnly == T, "inc_only", 
                        ifelse(BloatDecreaseOnly == T, "dec_only", 
                               ifelse(BloatIsStable == T, "stable", "variable")))) %>% select(Project, Class)

df_class_count <- df %>%
  count(Class)

df_slopes <- df_slopes %>% 
  rename(Project = Projects, Class = Sign) %>% 
  select(Project, Class)

df_classes <- full_join(df_class_count, df_slopes, by = "Project") %>% 
  mutate(Class = ifelse(is.na(Class.y) == T, Class.x, Class.y)) %>% 
  select(Project, Class, n)

df_classes$Class <- factor(df_classes$Class, levels = c("inc_only", "dec_only", "inc", "dec", "stable"))
result_plot <- df_classes %>% 
  ggplot(aes(Class, n)) +
  geom_violin(aes(fill = Class)) +
  geom_boxplot(width = 0.1) +
  xlab("Bloat trend") +
  ylab("Length (log scale)") +
  scale_y_log10() +
  theme(legend.position="none")

# Save the plot
ggsave(filename = "Figures/boxplot_length.pdf", plot = result_plot,
       height = 2, width = 4,  units = c("in"), device = "pdf")
save_figure(result_plot, "Figures/barplot_slope", 4, 2)
```

# Box plot of the difference between the end and the last value of the ts

```{r}
df_last <- results %>% 
  select(Project) %>% 
  group_by(Project) %>% 
  summarise(CommitOrder = n())

tmp <- results %>% 
  select(Project, CommitOrder, TotalBloated)

df_last <- inner_join(df_last, tmp, by = c("Project", "CommitOrder")) %>% 
  rename(LastBloat = TotalBloated)

df_first <- results %>% 
  filter(CommitOrder == 1) %>% 
  mutate(FirstBloat = TotalBloated) %>% 
  select(Project, FirstBloat)


# Difference between last and first bloat
df <- full_join(df_first, df_last) %>% 
  mutate(BloatDiff = LastBloat - FirstBloat) %>% 
  mutate(Trend = ifelse(BloatDiff > 0, "Positive", ifelse(BloatDiff < 0, "Negative", "Zero")))

table(df$Trend)

df %>% 
  ggplot(aes(x="Bloat diff", y=BloatDiff)) +
   geom_violin(aes(fill = "red")) +
  geom_boxplot(width = 0.1) +
  coord_flip()
  
```

# Line plot

```{r}
View(df_classes %>% 
  filter(n > 30 & n<100))


df <- results %>% 
  filter(Project %in% c("codelibs/elasticsearch-dataformat",
                        "stickfigure/hattery",
                        "Smartling/marketo-rest-sdk-java",
                        "jnr/jnr-ffi", 
                        "lob/lob-java")) %>% 
  mutate(`Bloat trend` = ifelse(Project == "codelibs/elasticsearch-dataformat", "inc",
                        ifelse(Project == "stickfigure/hattery", "inc_only",
                               ifelse(Project == "Smartling/marketo-rest-sdk-java", "dec_only",
                                     ifelse(Project == "jnr/jnr-ffi", "stable", "dec"))))) %>% 
  select(Project, CommitOrder, TotalBloated, `Bloat trend`) 


df$`Bloat trend` <- factor(df$`Bloat trend`, levels = c("inc_only", "dec_only", "inc", "dec", "stable"))
result_plot <- df %>% 
  ggplot(aes(CommitOrder, TotalBloated)) +
  geom_point(aes(shape = `Bloat trend`, color = Project)) +
  geom_line(aes(color = Project)) +
  theme(legend.position="right") +
  xlab("Length") +
  ylab("Value")


# Save the plot
ggsave(filename = "Figures/lineplot_projects.pdf", plot = result_plot,
       height = 3, width = 5,  units = c("in"), device = "pdf")
save_figure(result_plot, "Figures/barplot_slope", 4, 2)

```

# Stacked bar plot

```{r}
Type <- c("Monotonous", "Monotonous", "Variable", "Variable")
Trend <- c("Increasing", "Decreasing", "Increasing", "Decreasing")
N <- c(319, 192, 525, 178)

tmp <- data.frame(Type, Trend, N)

result_plot <- tmp %>% 
  ggplot(aes(Type, N, fill = Trend, label = N)) +
  geom_bar(stat = "identity") + 
  geom_text(size = 4, position = position_stack(vjust = 0.5)) +
  xlab("Time series") +
  ylab("Projects") +
  # coord_flip() +
  theme(legend.title=element_blank())

# Save the plot
ggsave(filename = "Figures/barplot_ts.pdf", plot = result_plot,
       height = 4, width = 6,  units = c("in"), device = "pdf")
save_figure(result_plot, "Figures/barplot_ts", 4, 2)

```

# Fitting several regression models

```{r}
library(broom)

lm <- df %>% 
  group_by(Project) %>%
  summarise(fit = lm(VersionOrder ~ Bloated)[[3]])
  
  
  do(fitBloated = tidy(lm(VersionOrder ~ Bloated, data = .))) %>% 
  unnest(fitBloated)

tmp <- df %>% 
  filter(Project == "0opslab/opslabJutil")
x <- tmp$VersionOrder
y <- tmp$Bloated
plot(x, y)
abline(mod <- lm(y ~ x))
coef(mod)

df %>% 
  ggplot(aes(VersionOrder, Bloated), color=Project) +
  geom_point(alpha = 0.1) +
  geom_line(alpha=0.1) 


```

```{r echo=FALSE}
results %>%
  filter(Project == "7le/shine-mq") %>%
  select(VersionOrder, NbDependencies) %>%
  ggplot(aes(x = VersionOrder, y = NbDependencies)) +
  ylim(0, 43) +
  geom_line() +
  geom_point()

library(jmotif)
library(forecast)

tmp <- results %>%
  filter(Project == "7le/shine-mq") %>%
  select(VersionOrder, NbDependencies)


library(pkr)
Slope(tmp$VersionOrder, tmp$NbDependencies)


tmp$NbDependencies <- znorm(tmp$NbDependencies, threshold = 0.01)
tmp %>%   
ggplot(aes(x = VersionOrder, y = NbDependencies)) +
  geom_line() +
  geom_point()



tmp <- results %>%
  filter(Project == "0opslab/opslabJutil") %>%
  select(VersionOrder, NbDependencies)

tmp$NbDependencies <- znorm(tmp$NbDependencies, threshold = 0.01)
tmp %>%   
ggplot(aes(x = VersionOrder, y = NbDependencies)) +
  geom_line() +
  geom_point()

time.series <- ts(tmp$NbDependencies) 

plot(time.series)
decompose(time.series, type = c("additive"))



```

# Correlation between variables

```{r echo=FALSE}
df <- results %>% 
  ungroup() %>% 
  select(NbDependencies, BloatedDirect, BloatedTransitive, UsedDirect, UsedTransitive, TotalBloated, TotalUsed)

cormat <- round(cor(df),2)
library(corrplot)
library(RColorBrewer)
corrplot(cormat, type="upper", order="hclust",
         col=brewer.pal(n=8, name="RdYlBu"))
```

# Z-normalize the time series

Simply put, a z-score (also called a standard score) gives you an idea of how far from the mean a data point is. But more technically it's a measure of how many standard deviations below or above the population mean a raw score is.

Z-scores are a way to compare results to a "normal" population. Results from tests or surveys have thousands of possible results and units; those results can often seem meaningless. For example, knowing that someone's weight is 150 pounds might be good information, but if you want to compare it to the "average" person's weight, looking at a vast table of data can be overwhelming (especially if some weights are recorded in kilograms). A z-score can tell you where that person's weight is compared to the average population's mean weight.

```{r echo=FALSE}
library(jmotif)
df <- results %>% 
  select(Project, CommitOrder, TotalBloated, TotalUsed) %>% 
  group_by(Project) %>% 
  mutate(BloatedZnorm = znorm(TotalBloated)) %>% 
  mutate(UsedZnorm = znorm(TotalUsed))
```
